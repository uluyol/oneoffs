// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: load.go

package u1proc

import (
	"bytes"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *Record) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *Record) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"T":`)
	fflib.WriteJsonString(buf, string(j.Type))
	buf.WriteString(`,"addr":`)
	fflib.WriteJsonString(buf, string(j.Addr))
	buf.WriteString(`,"caps":`)
	if j.Caps != nil {
		buf.WriteString(`[`)
		for i, v := range j.Caps {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if j.ClientMetadata == nil {
		buf.WriteString(`,"client_metadata":null`)
	} else {
		buf.WriteString(`,"client_metadata":{ `)
		for key, value := range j.ClientMetadata {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.WriteJsonString(buf, string(value))
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteString(`,"current_gen":`)
	fflib.FormatBits2(buf, uint64(j.CurrentGen), 10, j.CurrentGen < 0)
	buf.WriteString(`,"ext":`)
	fflib.WriteJsonString(buf, string(j.Ext))
	buf.WriteString(`,"failed":`)
	fflib.WriteJsonString(buf, string(j.Failed))
	buf.WriteString(`,"free_bytes":`)
	fflib.FormatBits2(buf, uint64(j.FreeBytes), 10, j.FreeBytes < 0)
	buf.WriteString(`,"from_gen":`)
	fflib.FormatBits2(buf, uint64(j.FromGen), 10, j.FromGen < 0)
	buf.WriteString(`,"hash":`)
	fflib.FormatBits2(buf, uint64(j.Hash), 10, j.Hash < 0)
	buf.WriteString(`,"level":`)
	fflib.WriteJsonString(buf, string(j.Level))
	buf.WriteString(`,"logfile_id":`)
	fflib.WriteJsonString(buf, string(j.LogfileID))
	buf.WriteString(`,"method":`)
	fflib.WriteJsonString(buf, string(j.Method))
	buf.WriteString(`,"mime":`)
	fflib.WriteJsonString(buf, string(j.Mime))
	buf.WriteString(`,"msg":`)
	fflib.WriteJsonString(buf, string(j.Msg))
	buf.WriteString(`,"node_id":`)
	fflib.FormatBits2(buf, uint64(j.NodeID), 10, j.NodeID < 0)
	buf.WriteString(`,"nodes":`)
	fflib.FormatBits2(buf, uint64(j.Nodes), 10, j.Nodes < 0)
	buf.WriteString(`,"pid":`)
	fflib.FormatBits2(buf, uint64(j.PID), 10, j.PID < 0)
	buf.WriteString(`,"req_id":`)
	fflib.FormatBits2(buf, uint64(j.ReqID), 10, j.ReqID < 0)
	buf.WriteString(`,"req_t":`)
	fflib.WriteJsonString(buf, string(j.ReqType))
	buf.WriteString(`,"root":`)
	fflib.FormatBits2(buf, uint64(j.Root), 10, j.Root < 0)
	buf.WriteString(`,"server":`)
	fflib.WriteJsonString(buf, string(j.Server))
	buf.WriteString(`,"shared_by":`)
	fflib.FormatBits2(buf, uint64(j.SharedBy), 10, j.SharedBy < 0)
	buf.WriteString(`,"shared_to":`)
	fflib.FormatBits2(buf, uint64(j.SharedTo), 10, j.SharedTo < 0)
	buf.WriteString(`,"shares":`)
	fflib.FormatBits2(buf, uint64(j.Shares), 10, j.Shares < 0)
	buf.WriteString(`,"sid":`)
	fflib.WriteJsonString(buf, string(j.SID))
	buf.WriteString(`,"size":`)
	fflib.FormatBits2(buf, uint64(j.Size), 10, j.Size < 0)
	buf.WriteString(`,"time":`)
	fflib.AppendFloat(buf, float64(j.DBTime), 'g', -1, 64)
	buf.WriteString(`,"tstamp":`)

	{

		obj, err = j.Timestamp.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(j.NodeType))
	buf.WriteString(`,"udfs":`)
	fflib.FormatBits2(buf, uint64(j.UDFS), 10, j.UDFS < 0)
	buf.WriteString(`,"user_id":`)
	fflib.FormatBits2(buf, uint64(j.UserID), 10, j.UserID < 0)
	buf.WriteString(`,"user":`)
	fflib.FormatBits2(buf, uint64(j.User), 10, j.User < 0)
	buf.WriteString(`,"vol_id":`)
	fflib.FormatBits2(buf, uint64(j.VolID), 10, j.VolID < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtRecordbase = iota
	ffjtRecordnosuchkey

	ffjtRecordType

	ffjtRecordAddr

	ffjtRecordCaps

	ffjtRecordClientMetadata

	ffjtRecordCurrentGen

	ffjtRecordExt

	ffjtRecordFailed

	ffjtRecordFreeBytes

	ffjtRecordFromGen

	ffjtRecordHash

	ffjtRecordLevel

	ffjtRecordLogfileID

	ffjtRecordMethod

	ffjtRecordMime

	ffjtRecordMsg

	ffjtRecordNodeID

	ffjtRecordNodes

	ffjtRecordPID

	ffjtRecordReqID

	ffjtRecordReqType

	ffjtRecordRoot

	ffjtRecordServer

	ffjtRecordSharedBy

	ffjtRecordSharedTo

	ffjtRecordShares

	ffjtRecordSID

	ffjtRecordSize

	ffjtRecordDBTime

	ffjtRecordTimestamp

	ffjtRecordNodeType

	ffjtRecordUDFS

	ffjtRecordUserID

	ffjtRecordUser

	ffjtRecordVolID
)

var ffjKeyRecordType = []byte("T")

var ffjKeyRecordAddr = []byte("addr")

var ffjKeyRecordCaps = []byte("caps")

var ffjKeyRecordClientMetadata = []byte("client_metadata")

var ffjKeyRecordCurrentGen = []byte("current_gen")

var ffjKeyRecordExt = []byte("ext")

var ffjKeyRecordFailed = []byte("failed")

var ffjKeyRecordFreeBytes = []byte("free_bytes")

var ffjKeyRecordFromGen = []byte("from_gen")

var ffjKeyRecordHash = []byte("hash")

var ffjKeyRecordLevel = []byte("level")

var ffjKeyRecordLogfileID = []byte("logfile_id")

var ffjKeyRecordMethod = []byte("method")

var ffjKeyRecordMime = []byte("mime")

var ffjKeyRecordMsg = []byte("msg")

var ffjKeyRecordNodeID = []byte("node_id")

var ffjKeyRecordNodes = []byte("nodes")

var ffjKeyRecordPID = []byte("pid")

var ffjKeyRecordReqID = []byte("req_id")

var ffjKeyRecordReqType = []byte("req_t")

var ffjKeyRecordRoot = []byte("root")

var ffjKeyRecordServer = []byte("server")

var ffjKeyRecordSharedBy = []byte("shared_by")

var ffjKeyRecordSharedTo = []byte("shared_to")

var ffjKeyRecordShares = []byte("shares")

var ffjKeyRecordSID = []byte("sid")

var ffjKeyRecordSize = []byte("size")

var ffjKeyRecordDBTime = []byte("time")

var ffjKeyRecordTimestamp = []byte("tstamp")

var ffjKeyRecordNodeType = []byte("type")

var ffjKeyRecordUDFS = []byte("udfs")

var ffjKeyRecordUserID = []byte("user_id")

var ffjKeyRecordUser = []byte("user")

var ffjKeyRecordVolID = []byte("vol_id")

// UnmarshalJSON umarshall json - template of ffjson
func (j *Record) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *Record) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtRecordbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtRecordnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'T':

					if bytes.Equal(ffjKeyRecordType, kn) {
						currentKey = ffjtRecordType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'a':

					if bytes.Equal(ffjKeyRecordAddr, kn) {
						currentKey = ffjtRecordAddr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyRecordCaps, kn) {
						currentKey = ffjtRecordCaps
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordClientMetadata, kn) {
						currentKey = ffjtRecordClientMetadata
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordCurrentGen, kn) {
						currentKey = ffjtRecordCurrentGen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeyRecordExt, kn) {
						currentKey = ffjtRecordExt
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeyRecordFailed, kn) {
						currentKey = ffjtRecordFailed
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordFreeBytes, kn) {
						currentKey = ffjtRecordFreeBytes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordFromGen, kn) {
						currentKey = ffjtRecordFromGen
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyRecordHash, kn) {
						currentKey = ffjtRecordHash
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyRecordLevel, kn) {
						currentKey = ffjtRecordLevel
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordLogfileID, kn) {
						currentKey = ffjtRecordLogfileID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyRecordMethod, kn) {
						currentKey = ffjtRecordMethod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordMime, kn) {
						currentKey = ffjtRecordMime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordMsg, kn) {
						currentKey = ffjtRecordMsg
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyRecordNodeID, kn) {
						currentKey = ffjtRecordNodeID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordNodes, kn) {
						currentKey = ffjtRecordNodes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyRecordPID, kn) {
						currentKey = ffjtRecordPID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyRecordReqID, kn) {
						currentKey = ffjtRecordReqID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordReqType, kn) {
						currentKey = ffjtRecordReqType
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordRoot, kn) {
						currentKey = ffjtRecordRoot
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyRecordServer, kn) {
						currentKey = ffjtRecordServer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordSharedBy, kn) {
						currentKey = ffjtRecordSharedBy
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordSharedTo, kn) {
						currentKey = ffjtRecordSharedTo
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordShares, kn) {
						currentKey = ffjtRecordShares
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordSID, kn) {
						currentKey = ffjtRecordSID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordSize, kn) {
						currentKey = ffjtRecordSize
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffjKeyRecordDBTime, kn) {
						currentKey = ffjtRecordDBTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordTimestamp, kn) {
						currentKey = ffjtRecordTimestamp
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordNodeType, kn) {
						currentKey = ffjtRecordNodeType
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyRecordUDFS, kn) {
						currentKey = ffjtRecordUDFS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordUserID, kn) {
						currentKey = ffjtRecordUserID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyRecordUser, kn) {
						currentKey = ffjtRecordUser
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffjKeyRecordVolID, kn) {
						currentKey = ffjtRecordVolID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffjKeyRecordVolID, kn) {
					currentKey = ffjtRecordVolID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordUser, kn) {
					currentKey = ffjtRecordUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordUserID, kn) {
					currentKey = ffjtRecordUserID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordUDFS, kn) {
					currentKey = ffjtRecordUDFS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordNodeType, kn) {
					currentKey = ffjtRecordNodeType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordTimestamp, kn) {
					currentKey = ffjtRecordTimestamp
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordDBTime, kn) {
					currentKey = ffjtRecordDBTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordSize, kn) {
					currentKey = ffjtRecordSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordSID, kn) {
					currentKey = ffjtRecordSID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordShares, kn) {
					currentKey = ffjtRecordShares
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordSharedTo, kn) {
					currentKey = ffjtRecordSharedTo
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordSharedBy, kn) {
					currentKey = ffjtRecordSharedBy
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordServer, kn) {
					currentKey = ffjtRecordServer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordRoot, kn) {
					currentKey = ffjtRecordRoot
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordReqType, kn) {
					currentKey = ffjtRecordReqType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordReqID, kn) {
					currentKey = ffjtRecordReqID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordPID, kn) {
					currentKey = ffjtRecordPID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordNodes, kn) {
					currentKey = ffjtRecordNodes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordNodeID, kn) {
					currentKey = ffjtRecordNodeID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordMsg, kn) {
					currentKey = ffjtRecordMsg
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordMime, kn) {
					currentKey = ffjtRecordMime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordMethod, kn) {
					currentKey = ffjtRecordMethod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordLogfileID, kn) {
					currentKey = ffjtRecordLogfileID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordLevel, kn) {
					currentKey = ffjtRecordLevel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordHash, kn) {
					currentKey = ffjtRecordHash
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordFromGen, kn) {
					currentKey = ffjtRecordFromGen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordFreeBytes, kn) {
					currentKey = ffjtRecordFreeBytes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordFailed, kn) {
					currentKey = ffjtRecordFailed
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordExt, kn) {
					currentKey = ffjtRecordExt
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordCurrentGen, kn) {
					currentKey = ffjtRecordCurrentGen
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffjKeyRecordClientMetadata, kn) {
					currentKey = ffjtRecordClientMetadata
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyRecordCaps, kn) {
					currentKey = ffjtRecordCaps
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordAddr, kn) {
					currentKey = ffjtRecordAddr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyRecordType, kn) {
					currentKey = ffjtRecordType
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtRecordnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtRecordType:
					goto handle_Type

				case ffjtRecordAddr:
					goto handle_Addr

				case ffjtRecordCaps:
					goto handle_Caps

				case ffjtRecordClientMetadata:
					goto handle_ClientMetadata

				case ffjtRecordCurrentGen:
					goto handle_CurrentGen

				case ffjtRecordExt:
					goto handle_Ext

				case ffjtRecordFailed:
					goto handle_Failed

				case ffjtRecordFreeBytes:
					goto handle_FreeBytes

				case ffjtRecordFromGen:
					goto handle_FromGen

				case ffjtRecordHash:
					goto handle_Hash

				case ffjtRecordLevel:
					goto handle_Level

				case ffjtRecordLogfileID:
					goto handle_LogfileID

				case ffjtRecordMethod:
					goto handle_Method

				case ffjtRecordMime:
					goto handle_Mime

				case ffjtRecordMsg:
					goto handle_Msg

				case ffjtRecordNodeID:
					goto handle_NodeID

				case ffjtRecordNodes:
					goto handle_Nodes

				case ffjtRecordPID:
					goto handle_PID

				case ffjtRecordReqID:
					goto handle_ReqID

				case ffjtRecordReqType:
					goto handle_ReqType

				case ffjtRecordRoot:
					goto handle_Root

				case ffjtRecordServer:
					goto handle_Server

				case ffjtRecordSharedBy:
					goto handle_SharedBy

				case ffjtRecordSharedTo:
					goto handle_SharedTo

				case ffjtRecordShares:
					goto handle_Shares

				case ffjtRecordSID:
					goto handle_SID

				case ffjtRecordSize:
					goto handle_Size

				case ffjtRecordDBTime:
					goto handle_DBTime

				case ffjtRecordTimestamp:
					goto handle_Timestamp

				case ffjtRecordNodeType:
					goto handle_NodeType

				case ffjtRecordUDFS:
					goto handle_UDFS

				case ffjtRecordUserID:
					goto handle_UserID

				case ffjtRecordUser:
					goto handle_User

				case ffjtRecordVolID:
					goto handle_VolID

				case ffjtRecordnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Type:

	/* handler: j.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Addr:

	/* handler: j.Addr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Addr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Caps:

	/* handler: j.Caps type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Caps = nil
		} else {

			j.Caps = []string{}

			wantVal := true

			for {

				var tmpJCaps string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCaps type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCaps = string(string(outBuf))

					}
				}

				j.Caps = append(j.Caps, tmpJCaps)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClientMetadata:

	/* handler: j.ClientMetadata type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ClientMetadata = nil
		} else {

			j.ClientMetadata = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJClientMetadata string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJClientMetadata type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJClientMetadata = string(string(outBuf))

					}
				}

				j.ClientMetadata[k] = tmpJClientMetadata

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CurrentGen:

	/* handler: j.CurrentGen type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.CurrentGen = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Ext:

	/* handler: j.Ext type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Ext = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Failed:

	/* handler: j.Failed type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Failed = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FreeBytes:

	/* handler: j.FreeBytes type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FreeBytes = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FromGen:

	/* handler: j.FromGen type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.FromGen = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Hash:

	/* handler: j.Hash type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Hash = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Level:

	/* handler: j.Level type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Level = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LogfileID:

	/* handler: j.LogfileID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LogfileID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Method:

	/* handler: j.Method type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Method = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mime:

	/* handler: j.Mime type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mime = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Msg:

	/* handler: j.Msg type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Msg = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeID:

	/* handler: j.NodeID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.NodeID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Nodes:

	/* handler: j.Nodes type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Nodes = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: j.PID type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PID = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReqID:

	/* handler: j.ReqID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ReqID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ReqType:

	/* handler: j.ReqType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ReqType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Root:

	/* handler: j.Root type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Root = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Server:

	/* handler: j.Server type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Server = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharedBy:

	/* handler: j.SharedBy type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SharedBy = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SharedTo:

	/* handler: j.SharedTo type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.SharedTo = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Shares:

	/* handler: j.Shares type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Shares = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_SID:

	/* handler: j.SID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.SID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Size:

	/* handler: j.Size type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.Size = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DBTime:

	/* handler: j.DBTime type=u1proc.FloatOrStr kind=float64 quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.DBTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Timestamp:

	/* handler: j.Timestamp type=u1proc.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.Timestamp.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NodeType:

	/* handler: j.NodeType type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NodeType = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UDFS:

	/* handler: j.UDFS type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UDFS = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserID:

	/* handler: j.UserID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.UserID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.User = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_VolID:

	/* handler: j.VolID type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.VolID = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
